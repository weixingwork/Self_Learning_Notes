---
创建者: WeiXing
类别:
  - 402 OS
---
# 从 OS 抽象到 Address Space

## 1. 操作系统的作用

- 应用程序**不能直接使用硬件**（CPU、内存、磁盘、网络等）。
- OS 提供 **抽象**（abstractions）：
    - 文件（file） → 对应磁盘
    - 进程（process/program） → 对应 CPU
    - 地址空间（address space） → 对应内存
    - 线程（thread） → 对应“执行流”

# 2. 文件抽象的例子

- 程序只看到 **文件**，不用管磁盘的物理细节。
- OS 负责命名、空间分配、容错、设备无关性等问题。

# 3. 程序的内存抽象：Address Space

操作系统把物理内存抽象成一个逻辑的 **地址空间**，应用程序员看到的是一块连续的内存区域。

主要分成几段：

- **Text (Code)**：存放编译后的指令，通常是只读的。
- **Data**：存放全局变量、静态变量。
    - 已初始化的（e.g., `int a = 5;`）
    - 未初始化的（BSS 段，e.g., `int b;`）
- **Heap (堆)**：存放动态分配的内存（`malloc/new`）。大小灵活，可跨函数使用。
- **Stack (栈)**：存放函数调用相关的数据（局部变量、参数、返回地址）。由编译器/OS 自动管理。

这里我们讨论了 **为什么局部变量在 stack，动态变量在 heap**：

- **局部变量 → Stack**：函数生命周期短、分配回收快、自动管理。
- **动态变量 → Heap**：需要跨函数存在、大小运行时决定、可能非常大、可共享。

口诀：

“小而临时的放 stack，大而灵活的放 heap”。

# 4. 什么时候需要动态变量？

- 当局部变量不够用时：
    1. 需要跨越函数生命周期（函数返回后还要用）
    2. 大小运行时才知道（文件大小、用户输入、网络数据包等）
    3. 数据量太大（stack 会爆）
    4. 多个函数/线程共享数据

我们还提到：

- 返回值**不是所有情况都要用 heap**，只有“返回一大块需要持久存在的数据”才需要动态分配。
- 小数据（int、double、小结构体）可以直接返回，不必上 heap。

# 5. Virtual Memory

- 由 **硬件 + 操作系统** 实现。
- 每个程序都认为自己有完整的地址空间（即使物理内存不够）。
- 概念：
    - **VA (Virtual Address)** → 程序看到的地址
    - **PA (Physical Address)** → 实际映射到的物理内存地址
- 优点：
    1. 每个程序都有独立的地址空间 → 相互隔离，提升安全性。
    2. 让物理内存像“扩展”了一样，配合磁盘做内存换页。
    3. 简化编程，程序员不必考虑内存如何共享

# 6. CPU 共享（Sharing of Processor）

- **问题**：只有一个 CPU，怎么运行多个程序？
- **抽象**：虚拟处理器（Virtual Processor），也叫线程 (Thread)。
- **Concurrency（并发）**：
    - 一个 CPU 在不同程序之间切换。
    - 需要保存和恢复 **execution context（执行上下文）**，这样程序能“接着跑”。
- **Parallelism（并行）**：
    - 如果有多核 CPU 或多颗 CPU，可以真正同时执行多个线程。
    - 本课程不区分并发和并行，统称为线程。
    - 需要解决 **调度与资源分配** 的问题。