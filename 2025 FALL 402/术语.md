---
创建者: WeiXing
类别:
  - 402 OS
---
# Lecture 2

### 操作系统与抽象

- **Operating System (OS)**：操作系统，提供抽象、管理硬件资源。
- **Abstraction**：抽象，把复杂的硬件细节封装成简化接口（如文件、进程）。
- **Process (Program)**：进程，正在运行的程序。
- **Thread**：线程，进程内的执行单元（虚拟处理器）。

---

### 内存相关

- **Address Space**：地址空间，程序看到的虚拟内存布局。
- **Text (Code) Segment**：代码段，存放程序的机器指令。
- **Data Segment**：数据段，存放全局变量/静态变量。
    - **Initialized Data**：已初始化的全局/静态变量。
    - **BSS (Block Started by Symbol)**：未初始化的全局/静态变量。
- **Stack**：栈，存放局部变量、函数参数、返回地址。
- **Heap**：堆，存放动态分配的内存。

---

### 变量类型

- **Local Variable**：局部变量，存在 stack 中，生命周期随函数结束。
- **Dynamic Variable**：动态变量，存在 heap 中，大小和生命周期由程序员控制。
- **Global Variable**：全局变量，存放在 data 段，整个程序运行期间存在。
- **Static Variable**：静态变量，也在 data 段，生命周期等于程序运行期。

---

### 内存共享与虚拟内存

- **Memory Sharing Option 1**：物理内存直接切分给不同程序（不灵活）。
- **Memory Sharing Option 2**：如果程序需要的内存超过物理内存，引出虚拟内存。
- **Virtual Memory (VM)**：虚拟内存，硬件+OS 提供的抽象，每个程序认为自己有完整内存。
- **VA (Virtual Address)**：虚拟地址，程序员看到的地址。
- **PA (Physical Address)**：物理地址，实际映射到的硬件内存。
- **Memory Isolation**：内存隔离，保证程序互不干扰。
- **Paging / Swapping**（预告性质）：通过磁盘扩展内存。

---

### CPU 共享

- **Concurrency（并发）**：单 CPU 在多个线程/进程之间切换。
- **Parallelism（并行）**：多 CPU/多核同时运行多个线程。
- **Execution Context**：执行上下文（寄存器、PC、栈指针等），用于保存/恢复线程状态。
- **Scheduling**：调度，决定哪个线程/进程在 CPU 上运行。

# Section 1.3

- **Sixth-Edition Unix** → 第六版 Unix，经典早期 OS。
- **Monolithic OS** → 单体内核操作系统。
- **Processor Modes** → 处理器模式。
    - **Privileged Mode (Kernel Mode)** → 特权模式，内核运行在此。
    - **User Mode** → 用户模式，普通应用运行在此。
- **Kernel** → 内核，运行在特权模式下的 OS 部分。
- **Trap** → 陷阱，程序通过系统调用进入 OS。
- **System Call** → 系统调用。
- **Interrupt** → 中断，外部设备发出的信号。
- **Interrupt Service Routine (ISR)** → 中断服务程序。
- **Registers** → 寄存器（EIP, ESP, EBP, EAX, EBX 等）。
- **Bus Architecture** → 总线架构。
- **Address Bus (A[0..31])** → 地址总线。
- **Data Bus (D[0..31])** → 数据总线。
- **Control Lines (RD, WR, INT, LOCK)** → 控制信号线。
- **Read Bus Cycle** → 读总线周期。
- **Write Bus Cycle** → 写总线周期。

# chap1-2
#### 关于变量存放位置
- 未初始化的全局变量和指针都存放在 bss段
- 局部变量全部在stack上，函数结束时直接释放
- malloc分配在heap上，需要手动free
### 进程process
- 创建进程就是把目前进程fork一份出来，已有的进程为parent process，新的child process
```
pid_t fork(void);
```
- 这就是函数的原型，fork会返回两次，在父进程返回pid，子进程返回0
-  PID是process ID 作为返回值
- 会复制一整个空间
- **PCB**是一个内核的数据结构，返回的是PID1,返回值，下一个PDB的指针
- 父进程通过wait调用返回码来知道子进程的信息比如PID和return code
- exec()方法让子进程去完成其他任务
- exit()方法是让子进程返回
```
pid_t wait(int *status);
```
- wait方法是父进程用来回收子进程的方法，但是一个blocking call
- 如果父进程先死亡，操作系统会把这些进程给1，叫做reparenting（重新收养）
```
int pid;
if ((pid = fork()) == 0) {
    /* child process */
    execl("/home/bc/bin/primes", "primes", "primes", "300", 0);
    exit(1);
}
/* parent continues here */
while (pid != wait(0))  /* ignore the return code */
    ;
```
- 1
```
int execl(const char *path, const char *arg, ...);
```
- **为什么要写 "primes" 两次？**
    
    - 第一个 "primes" 是 argv[0]（程序名）。
        
    - 第二个 "primes" 是真正传给程序的第一个参数。
        
    - 这是 Unix 的约定：argv[0] 通常放程序名，后面才是用户参数。
### 一些关于内存的内容
- - **EIP**：指令指针，指向下一条要执行的指令（比如 write()）。
        
    - **ESP**：栈顶指针。
        
    - **EBP**：基址指针。
# **Synchronization**
###  **互斥锁 (mutex)**
```
pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;

pthread_mutex_lock(&m);   // 加锁
x = x + 1;                // 临界区 (critical section)
pthread_mutex_unlock(&m); // 解锁
```
### **临界区 (Critical Section)**
- 这里的x= x+1 就是临界区的代码，同一时间只能有一个线程执行在临界区


